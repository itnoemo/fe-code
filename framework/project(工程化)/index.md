# 前端学习之路
- 语言本身(html、css、es)
- 工程化
- 框架
- 服务(node)
## 前工程化
>
### 模块化
> - 模块化简述
>   - 把复杂代码按功能的不同划分成不同的模块单独维护，提高开发效率，降低维护成本 模块化只是思想、理论，不包含具体实现
> - 模块化的诞生
>   - 简单来说，就是一个人做不完的事，分成了多个人做，每人负责一个块内容（模块），最后把每个人做的东西组装一起成为整体
前端模块化的演进道路上虽然有很多阶段，但是其实最终的目标，就是拆分模块，分工开发，每个人做好一个模块之后，暴露一些参数、方法给到调用者，演进的道路无非是秉行如何更加优雅，高解耦，高兼容等方向优化
> - 模块化的演进
>   - **第一阶段：仅仅基于文件的划分模块的方式**
    `具体做法就是将每个功能及其相关状态数据各自单独放到不同的文件中，约定每个文件就是一个独立的模块，使用某个模块就是将这个模块引入到页面中，然后直接调用模块中的成员（变量 / 函数）`
    缺点：所有模块都直接在全局工作，没有私有空间，所有成员都可以在模块外部被访问或者修改，而且模块一段多了过后，容易产生命名冲突，另外无法管理模块与模块之间的依赖关系
>   - **第二阶段：每个模块暴露一个全局对象，所有模块成员都挂载到这个对象中**
    `具体做法就是在第一阶段的基础上，通过将每个模块「包裹」为一个全局对象的形式实现，有点类似于为模块内的成员添加了「命名空间」的感觉。
    通过「命名空间」减小了命名冲突的可能，但是同样没有私有空间，所有模块成员也可以在模块外部被访问或者修改，而且也无法管理模块之间的依赖关系。`
>   - **第三阶段：使用立即执行函数表达式（IIFE：Immediately-Invoked Function Expression）为模块提供私有空间**
`具体做法就是将每个模块成员都放在一个函数提供的私有作用域中，对于需要暴露给外部的成员，通过挂在到全局对象上的方式实现
有了私有成员的概念，私有成员只能在模块成员内通过闭包的形式访问。`
>   - **第四阶段： 利用 IIFE 参数作为依赖声明使用**
    `具体做法就是在第三阶段的基础上，利用立即执行函数的参数传递模块依赖项。
这使得每一个模块之间的关系变得更加明显。`
>   - **第五阶段： 模块化规范**
    `Require.js 提供了 AMD 模块化规范，以及一个自动化模块加载器---模块化规范的出现，再之后便有了其他更多标准紧接而来，CommonJS、CMD。。。`
#### [commonjs](./commonjs.md)
-  一个文件就是一个模块 每个模块都有单独的作用域 通过 module.exports 导出成员 通过 require 函数载入模块
- 一般用在服务端(nodejs)
- CommonJS的核心思想是通过rquire方法来同步加载依赖的其他模块，通过module.exports到处需要暴露的接口
```js
// 导出
module.exports = moduleA.someFunc;
//导入
const moduleA = require('./moduleA')
```
#### [ES Module](./esmodule.md)
- 概念
    - ES6 在语言标准的层面上，实现了模块功能，成为浏览器和服务器通用的模块解决方案
    - ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器
#### AMD
- 概念
    - 是一个异步模块加载的规范
    - 模块必须采用特定的define()函数来定义
- 定义
```js
// 无任何依赖时
define(function (){
　　var add = function (x,y){
　　　　return x+y;
　　};
　　return {
　　　add: add
　　};
});
// 有依赖时,先异步加载完a和b两个文件后再去执行回调函数
define(['./a.js', './b.js'], function (){
　　var add = function (x,y){
　　　　return x+y;
　　};
　　return {
　　　add: add
　　};
});
```
- 引入
    - require.js加载的模块，采用AMD规范
```js
require(['math'], function (math){
　　alert(math.add(1,1));
});
```
- [requirejs](https://www.ruanyifeng.com/blog/2012/11/require_js.html)
    - 诞生
        - 实现js文件的异步加载，避免网页失去响应；
　　    - 管理模块之间的依赖性，便于代码的编写和维护。

#### [UMD](./umd.md)
- 一种javascript通用模块定义规范，让你的模块能在javascript所有运行环境中发挥作用
#### [常见问题](./faq.md)
----
### 包管理
#### 相关概念
- 包是什么
`
包是一段可以复用的代码，这段代码可以从全局注册表下载到开发者的本地环境。每个包可能会，也可能不会依赖于别的包
`
- 包管理器是什么
`
包管理器是一段代码，它可以让你管理依赖（你或者他人写的外部代码），你的项目需要这些依赖来正确运行
`
- 作用
    - 处理和编写元数据
    - 批量安装或更新所有依赖项
    - 添加、更新和删除依赖项
    - 运行脚本
    - 发布软件包
    - 进行安全审查
#### 常用工具
- [npm](./npm/npm.md)
    - npm 是 Node.js 自带的包管理器，平时通过 npm install 命令来安装各种 npm 包
    - 包的版本锁定文件是 package-lock.json ，如果有管理多人协作仓库的需求，可以根据实际情况把它添加至 .gitignore 文件，便于统一团队的包管理
- [yarn](./npm/npm.md)
    - 和npm类似，后面将npm和yarn一起对比讲解
- [pnpm](./pnpm.md)
#### [package.json](./package/package.json.md)
- 概念
    - 是一个用于描述和配置项目的重要文件，其中包含了许多字段和选项，可以影响项目的构建、依赖管理、脚本执行等方面
----
### 构建工具
### 脚手架